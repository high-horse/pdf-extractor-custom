package main

import (
	// "errors"
	"fmt"
	"image/jpeg"
	"log"
	"math"
	"sort"
	"time"

	// "io/fs"
	"os"
	"path/filepath"
	"regexp"

	"github.com/unidoc/unipdf/v4/common/license"
	"github.com/unidoc/unipdf/v4/extractor"
	"github.com/unidoc/unipdf/v4/model"
)

const (
	UNIDOC_LICENSE_API_KEY = "38311761653b7d673d05b475e0a29fbca0d87f42b623d9f7dd016f900dbdcdd4"
	INPUT_FILE             = "input/sample.pdf" // Note: you have "imput" â€“ probably typo for "input"?
	OUTPUT_DIR             = "output/"
)

var (
	// Regex to find 8-digit citizen IDs (common in Nepal voter lists)
	// idRegex = regexp.MustCompile(`\b\d{8}\b`)
	idRegex = regexp.MustCompile(`\b[\p{Nd}]{8}\b`)
)

func init() {
	// Set your metered license key (free tier available at https://cloud.unidoc.io)
	err := license.SetMeteredKey(UNIDOC_LICENSE_API_KEY)
	if err != nil {
		panic(err)
	}

}

func main() {
	file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	log.SetOutput(file)
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)

	log.Println("starring ...")
	startTime := time.Now()
	fmt.Printf("Input file: %s\n", INPUT_FILE)
	fmt.Printf("Output directory: %s\n", OUTPUT_DIR)

	// err := extractImagesToFolder(INPUT_FILE, OUTPUT_DIR)
	err = extractImagesWithIDNames(INPUT_FILE, OUTPUT_DIR)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		os.Exit(1)
	}

	time.Sleep(1 * time.Second)
	endTime := time.Since(startTime)

	fmt.Printf("Completed in %.2f seconds \t %d mi\n", endTime.Seconds(), endTime.Milliseconds())
}

// Extracts images and names them using the 8-digit ID number found on the same page
func extractImagesWithIDNames_old(inputPath, outputDir string) error {
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		return err
	}

	pdfReader, f, err := model.NewPdfReaderFromFile(inputPath, nil)
	if err != nil {
		return err
	}
	defer f.Close()

	numPages, err := pdfReader.GetNumPages()
	if err != nil {
		return err
	}

	fmt.Printf("Processing %d page(s)\n", numPages)

	totalExtracted := 0

	for pageNum := 1; pageNum <= numPages; pageNum++ {
		if pageNum == 1 {
			continue
		}
		fmt.Printf("\n--- Page %d ---\n", pageNum)

		page, err := pdfReader.GetPage(pageNum)
		if err != nil {
			return err
		}

		// Extract text from the page to find IDs
		textExtractor, err := extractor.New(page)
		if err != nil {
			return err
		}
		text, err := textExtractor.ExtractText()
		if err != nil {
			fmt.Printf("Warning: Could not extract text from page %d: %v\n", pageNum, err)
			text = ""
		}
		log.Println("extracted %v", text)
		panic("panic")

		// Find all 8-digit numbers (citizen IDs)
		ids := idRegex.FindAllString(text, -1)
		fmt.Printf("Found %d candidate ID(s) on page: %v\n", len(ids), ids)

		// Extract images from the same page
		imgExtractor, err := extractor.New(page)
		if err != nil {
			return err
		}
		pageImages, err := imgExtractor.ExtractPageImages(nil)
		if err != nil {
			return err
		}

		imgCount := len(pageImages.Images)
		fmt.Printf("Found %d image(s) on page\n", imgCount)

		if imgCount == 0 {
			continue
		}

		// Use available IDs in order; fallback to sequential naming if not enough
		for i, img := range pageImages.Images {
			if i <= 2 {
				continue
			}
			gimg, err := img.Image.ToGoImage()
			if err != nil {
				return err
			}

			var filename string
			if i < len(ids) && len(ids[i]) == 8 {
				filename = ids[i] + ".jpg" // e.g., 19326330.jpg
			} else {
				// Fallback naming
				filename = fmt.Sprintf("page%d_image%d.jpg", pageNum, i+1)
			}

			fullPath := filepath.Join(outputDir, filename)

			outFile, err := os.Create(fullPath)
			if err != nil {
				return err
			}

			err = jpeg.Encode(outFile, gimg, &jpeg.Options{Quality: 90})
			outFile.Close()
			if err != nil {
				return err
			}

			fmt.Printf("Saved: %s\n", filename)
			totalExtracted++
		}
	}

	fmt.Printf("\nDone! Extracted %d image(s) to %s\n", totalExtracted, outputDir)
	return nil
}

// Extracts images from a PDF and saves them as individual JPEG files in the output directory.
func extractImagesToFolder(inputPath, outputDir string) error {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		return err
	}
	log.Println("Created dir")

	// Open PDF
	pdfReader, f, err := model.NewPdfReaderFromFile(inputPath, nil)
	log.Println("opening pdf")
	if err != nil {
		return err
	}
	defer f.Close()

	numPages, err := pdfReader.GetNumPages()
	if err != nil {
		return err
	}

	fmt.Printf("PDF has %d pages\n", numPages)

	totalImages := 0

	for i := 0; i < numPages; i++ {
		fmt.Printf("-----\nProcessing Page %d:\n", i+1)

		page, err := pdfReader.GetPage(i + 1)
		if err != nil {
			return err
		}

		pextract, err := extractor.New(page)
		if err != nil {
			return err
		}

		pimages, err := pextract.ExtractPageImages(nil)
		if err != nil {
			return err
		}

		fmt.Printf("Found %d image(s) on this page\n", len(pimages.Images))

		for idx, img := range pimages.Images {
			// Convert to Go image
			gimg, err := img.Image.ToGoImage()
			if err != nil {
				return err
			}

			// Create unique filename: page_index (1-based)
			filename := fmt.Sprintf("page%d_image%d.jpg", i+1, idx+1)
			fullPath := filepath.Join(outputDir, filename)

			// Save as JPEG
			outFile, err := os.Create(fullPath)
			if err != nil {
				return err
			}

			opts := &jpeg.Options{Quality: 90} // Good quality
			err = jpeg.Encode(outFile, gimg, opts)
			outFile.Close()
			if err != nil {
				return err
			}

			fmt.Printf("Saved: %s (Position: X=%.2f Y=%.2f, Size: %.2fx%.2f)\n",
				filename, img.X, img.Y, img.Width, img.Height)
		}

		totalImages += len(pimages.Images)
	}

	fmt.Printf("Done! Extracted total %d image(s) to %s\n", totalImages, outputDir)
	return nil
}
